# Nok lang (녹 언어) 0.1.0 c1
작성자가 고안 중인 프로그래밍 언어/ 스크립트 언어입니다.
범용 프로그래밍 언어로 컨셉을 정했으나, 필요에 따라 도메인 특화 언어(또는 Godot처럼 자체 엔진에 쓰이는 방향)로 전향할 가능성이 높습니다.

- 25/12/19 수정

# 주석 (Comment)
문장 단위 주석, 블록 단위 주석이 있습니다.

- 문장 단위 : `~`를 사용
- 블록 단위 : `'~{` `}~'`로 표현

# 기호, 리터럴, 표기법
Nok은 정적 타입 언어입니다. 
그에 따른 표기법이 비교적 많습니다.
- 상수(정수, 실수, 문자, 문자열)

- 배열

C언어의 경우
```
int a[]={1,2,3,4}; //알아서 사이즈 관리함. 편함
int a[][]={{1,2,3,4},{5,6,..}..} //이 경우 오류가 걸림.
int a[10]={1,2,3}; //이 뒤에는 0으로 채워지는가?

int a[11]={1,2,3,4,5,6,7, ... ,10}; //11 사이즈를 넘으면 오류 걸림
```


# 자료형 (Type)
파이썬처럼 mut(가변), immut(불변) 두 가지를 지원, 
기본 자료형은 반드시 immut에 속함
## 기본 자료형 (Basic Type)
### 불변(Immutable Type)
- 정수
- 문자
- 문자열 상수
 
**문자**
- `byte`/`i8` 1byte
- `short`/`i16` 2byte
- `int`/`i32` 4byte
- `long`/`i64` 8byte
- `ubyte`/`u8`, `ushort`/`u16`, `uint`/`u32`, `ulong`/`u64`
- `float`/`f32` 4byte
- `double`/`f64` 8byte

**문자**
- `ascii`/`c8` 1byte
- `char`/`c16` 2byte

`char`는 Java처럼 2바이트 와이드캐릭터를 사용, 0~2^16-1 사용가능<br>
(굳이 1바이트를 쓸거면 byte 권장)


**문자열**
`str`는 Rust처럼 문자열 리터럴
### 가변 (Mutable Type)
- Array
- Dict

필요에 따라 추가 예정<br>
클래스로 선언한 식별자는 전부 가변형(Mutable Type)임
### Array, Tuple
#### 2-1. 고정 배열과 튜플
Nok lang에서 독특한 점 중 하나는 배열을 다루는 방식입니다.
[]를 통해서 배열, 튜플을 동시에 정의할 수 있습니다.

LLVM, Rust의 배열 선언방식과 유사합니다. (영향을 받은건 아님. 굳이 따지면 수렴진화?)

```
~ 배열
:[int] ~크기 1의 int 배열로 취급
:[int*1] ~똑같음
:[int*2] ~크기 2의 int 배열
~ 튜플
:[int, int] ~ 튜플
:[int, float] ~ 튜플
:[int*2, float*2] ~ :[int int float float]와 같음
:[int 2 float 2] ~ 가능

a:[int, int]=[100 200] ~ a:[int*2]=[100 200]
```

이런 식의 선언방식을 통해 배열, 튜플 동시에 나타낼 수 있습니다.<br>
`:[int, int]`는 `:[int int]` 식으로 콤마를 생략해 쓸 수도 있습니다. `int*3`에서 뒤에 정수 리터럴리 오는 경우 `*` 생략 가능<br>
`int*size`의 경우는 불가능

```
#가능한 문법
:[int, int, int]
:[int int int]
:[int*3]
:[int 3]
:[int*size] #size:int=100 일 때

#문법 오류
:[int size] #동적 할당의 경우 반드시 * 사용
```
`:[int int]`와 `:[int*2]`는 사용방식은 비슷하나, 왼쪽은 튜플로써, 오른쪽은 배열로 처리됩니다.<br>
처음에는 통합하려 했는데 일관성이나 뒤에 *객체*를 표현할때 튜플로 타입을 나타낼텐데, 배열과 튜플이 혼용되면 곤란하기 때문입니다. <br> 



#### 2-2. 다중 배열
`:[[int*5]*5]`
처럼 사용하면 됩니다. 이는 5*5 배열을 의미합니다.
좀 보기 싫겠지만 익숙해지면 그만임
```
arr:[[int*3]*3]=[[1,2,3],[4,5,6],[7,8,9]]
mixarr:[[int float]*2]=[[1 10.f][3 1.f]]
```

#### 2-3. 동적 배열
위 처럼 사용하면 정적 배열(고정 배열)이 되나, 동적 배열을 사용하려면 `[int **]` 처럼 쓸 수 있습니다.
```
size:int=100
darr:[int **]=[1,2,3,4] #
darr2:[int*size] #size 크기의 배열 할당 (size>0을 만족하지 않으면 런타임에서 오류)
```
선언이 귀찮을 때 `arr=[1,2,3,4 ;*]` 같이 넣을까 생각도 해봤는데 아직 미정.<br>
참고로 튜플은 고정 크기이므로 
```[int*2 float **]``` 는 불가능한 문법입니다.
사실 재미는 있지만 메모리 관리 면에서 번거로울 듯 하여서

### Dict
Dict<str,int>처럼 별도로 선언하는 방식도 있으나, 배열과 마찬가지로
`[str:int]`
를 사용할 수도 있습니다.
```
dict_i2i:[int:int]=[0:10, 1:50]
dict_s2i:[str:int]=['myson':100, 'yourson':200]

prices:[str:int]=['김밥':2000 '떡볶이':3500 '순대':3000]
prices['김밥'] #2000


```
Key는 immut 타입만 지원할 수 있습니다.


## 객체(Object) 기능?
"컴파일러 구현하기 어려우면 NG"라는 규칙에 따라서<br>
클래스 기반 언어가 되진 않을것 같습니다. 클래스의 기능은 막강한 반면 키워드 규칙 등이 많습니다.
절차지향은 아니지만 Go처럼 무늬는 흉내내는 느낌으로 구상 중

```
#[float float]? [float 2]
struct Pos
  x:float
  y:float
end
func main
  pos:Pos
  print(10,-20, -30, -40)

n=84
[int 3]
[float 4]

[int int]
[float float]
[[float float]2 int 2]
[float *]
[Pos ]
struct Chara
  use Pos
  
:[str:Chara]

```

# 구문 분석 시 발견되는 문제가 있는가

발견하면 바로 수정함


