# Nok lang (녹 언어) 0.1.0 c1
작성자가 고안 중인 프로그래밍 언어/ 스크립트 언어입니다.
범용 프로그래밍 언어로 컨셉을 정했으나, 필요에 따라 도메인 특화 언어(또는 Godot처럼 자체 엔진에 쓰이는 방향)로 전향할 가능성이 높습니다.

- 25/12/19 수정
  
# 버전 넘버링
0.1.0 a1, a2, a3 ... 과 b1, b2... 는 서로 호환이 안 되는 문법임<br>
즉, 문제가 생겼거나 문법을 바꾸는 경우 a->b, b->c로 바뀌며,<br>
이전 a 버전은 별도로 "복구"한다는 얘기가 없으면 폐기됨 (그런 설정임) <br>
z 뒤에는 aa, ab.. 순서로 시작<br>
a>b>c>...z>aa>ab>ac...>zz>aaa...


## 참고 언어
- 접해본 언어들 (C/C++ C# Java Kotlin Rust Go Delphi/Object Pascal Dart Javascript Typescript PHP Python Ruby Prolog Lua )
- 단, 중점적으로는 C/C++, Python, Ruby, Rust, Mojo Crystal도 참고
- 학습용 페이지 [プログラミング言語を作ろう](https://kmaebashi.com/programmer/devlang/index.html)

구현체는 C/C++
현재는 VM 위에 작동하는 바이트코드 언어로 구현하려고 함.

## 목표/철학
뚜렷한 목표나 거창한건 없으며, 어느 언어를 대체한다는 목적도 아닙니다. 

다만 최소한의 목표, 철학은 
- 제1원칙 **컴파일러 구현하기 어렵지 않아야 함**
- 제2원칙 **간결한 문법, 사용하기 편해야 함**
- 제3원칙 **기존 언어에서 부족한 점을 보완**
- 제4원칙 개인적으로 있으면 **좋을거 같은 기능** 추가
- 제5원칙 **성능 하락**을 기피

그에 따라
- Garbage Collector 없음 (레퍼런스 카운팅 혹은 아레나 할당 지원 예정)
- 구문 분석 시 가능하면 귀찮은거 생략 (콤마, 세미콜론, 괄호 등)
- 정적 타입 언어

# 구문 분석
구문분석기를 만들다 보니 생략이 가능하거나 필요없는 문법이 있다는걸 발견했습니다.

## 생략 여부 - LL 파서 기준
- 세미콜론
- 콤마 : 일반적으로 생략 가능. (10, -30)같은 경우는 불가능
- 중괄호 : {는 필요없고, }만 써도 됨. 파이썬 식의 Tab 지원도 가능함.
- 괄호(수식 제외) : if (~~)에서 ()는 생략 가능

그에 따라
- 세미콜론, 괄호 : 생략
- 콤마 : 생략 가능 (선택)
- 블록 : {}를 선호하나, 현재는 end로 정함.

## 문법 및 코드 스타일에 대해
개인적으로 엄격한 문법검사를 선호하지 않습니다. 
이유
- 구문 분석, 에러 처리가 복잡해짐
- 자유도 및 편이성이 떨어짐. 파이썬처럼 탭 스페이스에 강박적인 경우

```
~ 스타일 1
while true
  ~ 내용
end

~ 스타일 2
while true end
```

문법이 자유로운 경우 아래와 같은 단점도 예상됩니다.
- 개발자의 실수
- 가독성의 저해 가능성 : 띄어쓰기 중괄호 탭 등등
- 구조 분석의 어려움

C/C++ 같은 언어에서 중괄호 위치에 따라 논쟁이 있는 것,
언어마다 고정된 스타일을 중요시한다는 것은 잘 알고 있습니다.

그럼에도, 
구현이 어려워지고, 파싱 속도가 떨어지는 것은 제 철학 1,2에 위배됩니다.
현업을 위한 언어가 아닌, 개인 목적의 개발언어이기 때문이라는 점을 감안하여
개발자의 몫이라고 판단하여 제 기준으로 불필요한 구문분석은 생략합니다.

개인적으로 권장하는 코드 스타일은 올리도록 하겠습니다.

## 블록에 대해
일반적으로 파이썬이 최근 강력하게 쓰이고 있습니다.<br>
만, 그 때문에 탭, 공백문자, 엔터키를 마음놓고 못 씁니다.

Tab 단위로 블록을 관리한다는 점이 파이썬의 장점인 동시에 단점입니다. <br>
탭을 정확히 맞춰야 하고, 탭이 없어지면 코드 정보가 산산조각 난다는 무서운 점도 있습니다.<br>
일반적으로 space 4를 하나의 탭으로 보는데, 스페이스를 정확히 맞추는건 어려운 일입니다.<br>
ReadME 파일에서도 space 2로 인식됨

```
if state1():
  print(10)

```
파이썬 블록을 포기한다해도, 중괄호 {}는 아직 미정이나 특수한 용도로 사용하는게 좋을 것 같다고 판단했습니다.
따라서 ruby, lua처럼 end를 쓰도록 했습니다. <br>
`do`는 쓰지 않습니다.
단, 파이썬 루비 둘 다 블록을 시작할때 : do를 쓰나, 의미가 없으므로(**제3원칙**) Nok lang에선 생략합니다.

물론 파이썬 방식을 포기하면, 여전히 번거롭게
```
{{{{ }}}}
    end
  end
end
```

이런 노가다를 해야할 수 있습니다. 아직까지는 Tab을 이용하지 않으면 해결할 수 없는 문제입니다.<br>
그럼에도, 조금 줄일 수 있는 팁이 있다고 하면, `endfunc` 같은 키워드 만들거나VB Net처럼 `end func` `end:func` 이런식으로 하는 것 입니다.
그러면 짜잔
```
func main()
  while blabla
    if n==10
      io.print('어쩌고 저쩌고')
end:func

근데 생각해보니 }}} 이렇게 쓰면 되는거 아닌가?
```

완벽하진 않아도 쉽게 축약이 됩니다. 파이썬 정도는 아니라도 비슷한 효과를 낼 수는 있죠<br>
마음에 안 들면 님이 해보셈 <br>
다른 방식도 있는데 굳이 설명 안하겠습니다. 궁금하면 예전에 만든 [ipari 스크립트](https://github.com/Noksek2/ipari-script) 참고

- Python : 축약 O, 탭 독립성 X
- Ruby : 축약 X, 탭 독립성 O
- Nok : 축약 △, 탭 독립성 O

# 자료형 (Type)
파이썬처럼 mut(가변), immut(불변) 두 가지를 지원, 
기본 자료형은 반드시 immut에 속함
## 기본 자료형 (Basic Type)
### 불변(Immutable Type)
- 정수
- 문자
- 문자열 상수
 
**문자**
- `byte`/`i8` 1byte
- `short`/`i16` 2byte
- `int`/`i32` 4byte
- `long`/`i64` 8byte
- `ubyte`/`u8`, `ushort`/`u16`, `uint`/`u32`, `ulong`/`u64`
- `float`/`f32` 4byte
- `double`/`f64` 8byte

**문자**
- `ascii`/`c8` 1byte
- `char`/`c16` 2byte

`char`는 Java처럼 2바이트 와이드캐릭터를 사용, 0~2^16-1 사용가능<br>
(굳이 1바이트를 쓸거면 byte 권장)


**문자열**
`str`는 Rust처럼 문자열 리터럴
### 가변 (Mutable Type)
- Array
- Dict

필요에 따라 추가 예정<br>
클래스로 선언한 식별자는 전부 가변형(Mutable Type)임
### Array, Tuple
#### 2-1. 고정 배열과 튜플
Nok lang에서 독특한 점 중 하나는 배열을 다루는 방식입니다.
[]를 통해서 배열, 튜플을 동시에 정의할 수 있습니다.

LLVM, Rust의 배열 선언방식과 유사합니다. (영향을 받은건 아님. 굳이 따지면 수렴진화?)

```
~ 배열
:[int] ~크기 1의 int 배열로 취급
:[int*1] ~똑같음
:[int*2] ~크기 2의 int 배열
~ 튜플
:[int, int] ~ 튜플
:[int, float] ~ 튜플
:[int*2, float*2] ~ :[int int float float]와 같음
:[int 2 float 2] ~ 가능

a:[int, int]=[100 200] ~ a:[int*2]=[100 200]
```

이런 식의 선언방식을 통해 배열, 튜플 동시에 나타낼 수 있습니다.<br>
`:[int, int]`는 `:[int int]` 식으로 콤마를 생략해 쓸 수도 있습니다. `int*3`에서 뒤에 정수 리터럴리 오는 경우 `*` 생략 가능<br>
`int*size`의 경우는 불가능

```
#가능한 문법
:[int, int, int]
:[int int int]
:[int*3]
:[int 3]
:[int*size] #size:int=100 일 때

#문법 오류
:[int size] #동적 할당의 경우 반드시 * 사용
```
`:[int int]`와 `:[int*2]`는 사용방식은 비슷하나, 왼쪽은 튜플로써, 오른쪽은 배열로 처리됩니다.<br>
처음에는 통합하려 했는데 일관성이나 뒤에 *객체*를 표현할때 튜플로 타입을 나타낼텐데, 배열과 튜플이 혼용되면 곤란하기 때문입니다. <br> 



#### 2-2. 다중 배열
`:[[int*5]*5]`
처럼 사용하면 됩니다. 이는 5*5 배열을 의미합니다.
좀 보기 싫겠지만 익숙해지면 그만임
```
arr:[[int*3]*3]=[[1,2,3],[4,5,6],[7,8,9]]
mixarr:[[int float]*2]=[[1 10.f][3 1.f]]
```

#### 2-3. 동적 배열
위 처럼 사용하면 정적 배열(고정 배열)이 되나, 동적 배열을 사용하려면 `[int **]` 처럼 쓸 수 있습니다.
```
size:int=100
darr:[int **]=[1,2,3,4] #
darr2:[int*size] #size 크기의 배열 할당 (size>0을 만족하지 않으면 런타임에서 오류)
```
선언이 귀찮을 때 `arr=[1,2,3,4 ;*]` 같이 넣을까 생각도 해봤는데 아직 미정.<br>
참고로 튜플은 고정 크기이므로 
```[int*2 float **]``` 는 불가능한 문법입니다.
사실 재미는 있지만 메모리 관리 면에서 번거로울 듯 하여서

### Dict
Dict<str,int>처럼 별도로 선언하는 방식도 있으나, 배열과 마찬가지로
`[str:int]`
를 사용할 수도 있습니다.
```
dict_i2i:[int:int]=[0:10, 1:50]
dict_s2i:[str:int]=['myson':100, 'yourson':200]

prices:[str:int]=['김밥':2000 '떡볶이':3500 '순대':3000]
prices['김밥'] #2000


```
Key는 immut 타입만 지원할 수 있습니다.


## 객체(Object) 기능?
"컴파일러 구현하기 어려우면 NG"라는 규칙에 따라서<br>
클래스 기반 언어가 되진 않을것 같습니다. 클래스의 기능은 막강한 반면 키워드 규칙 등이 많습니다.
절차지향은 아니지만 Go처럼 무늬는 흉내내는 느낌으로 구상 중

```
#[float float]? [float 2]
struct Pos
  x:float
  y:float
end
func main
  pos:Pos
  print(10,-20, -30, -40)

n=84
[int 3]
[float 4]

[int int]
[float float]
[[float float]2 int 2]
[float *]
[Pos ]
struct Chara
  use Pos
  
:[str:Chara]

```

# 구문 분석 시 발견되는 문제가 있는가

발견하면 바로 수정함


