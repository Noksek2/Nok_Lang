# Nok lang (녹 언어) 0.1.0 b1
이름은 닉네임 앞 글자 따서 만듦<br>여러번 갈아엎어서 구상하다가 포기하고 차근하게 아이디어 제대로 세우게 됨

실제로 구현할거 같진 않고, 의사코드처럼 수 많은 언어를 공통적인 방법으로 표현하는 수단으로 쓸 지 생각중<br>
검증도 안된 언어 구현체를 만드실 분이 있을리는 없으므로 ㅋㅠ<br>
재미삼아 봐주시면 감사드리겠습니다

# 버전 넘버링
0.1.0 a1, a2, a3 ... 과 b1, b2... 는 서로 호환이 안 되는 문법임<br>
즉, 문제가 생겼거나 문법을 바꾸는 경우 a->b, b->c로 바뀌며,<br>
이전 a 버전은 폐기됨<br>
z 뒤에는 aa, ab.. 순서로 시작<br>
a>b>c>...z>aa>ab>ac...>zz>aaa...


## 참고 언어
- **접해본 모든 언어 (C/C++ C# Java Kotlin Rust Go Delphi/Object Pascal Dart Javascript Typescript PHP Python Ruby Prolog Lua )**
- 단, 중점적으로는 C/C++, Python, Ruby, Rust 정도

- 마이너하지만 Mojo Crystal도 참고
- 학습용 페이지 [プログラミング言語を作ろう](https://kmaebashi.com/programmer/devlang/index.html)

물론 모든 기능을 넣을수는 없고, 쉬운 언어를 만드는게 목적이므로 <br>
[Crystal](https://crystal-lang.org/) 처럼 간결하지만 개인적인 욕심기능을 추가할까 생각중<br>

구현체는 왠만하면 C/C++로 만들예정<br>
문서는 필요에 따라 세분화

개인적으로 실력상 동적 언어를 만드는게 현실적이나<br>
컴파일 언어를 구현하면 멋질거 같아서 ** 정적 타이핑 + 컴파일 언어 **를 구상중

## 목표/철학
뚜렷한 목표나 거창한건 없습니다. 어느 언어를 대체한다는 목적도 교육용 목적도 아닙니다.

다만 최소한의 목표, 철학은 
- **컴파일러 구현하기 어렵지 않아야 함**
- **사용하기 편해야 함**
- **기존 언어에서 부족한 점을 보완**
- 구문 분석 시 가능하면 귀찮은거 생략 (콤마, 세미콜론, 괄호 등)

궁극적으로
- 개인적으로 있으면 **좋을거 같은 기능**

을 되도록 많이 집어넣는 것 입니다.
# 구문 분석
구문분석기를 만들다 보니 생략이 가능하거나 필요없는 문법이 있다는걸 발견했습니다.

## 생략 여부
- 세미콜론 : 무쓸모
- 콤마 : 일반적으로 생략 가능. (10, -30)같은 경우는 불가능
- 중괄호 : 그냥 }만 썼으면 좋겠는데 이상하니까 end로 대체
- 괄호(수식 제외) : if (~~) 생략 가능 

따라서
- 세미콜론, 괄호 : 생략
- 콤마 : 생략 가능 (선택)
이렇게 정했습니다.

## 블록은?
일반적으로 파이썬이 최근 강력하게 쓰이고 있습니다.<br>
만, 그 때문에 탭, 공백문자, 엔터키를 마음놓고 못 씁니다.

무엇보다 Tab 단위로 블록을 관리한다는 점이 장점인 동시에 단점입니다. <br>
탭을 정확히 맞춰야 하고, 탭이 없어지면 코드 정보가 산산조각 난다는 무서운 점도 있습니다.<br>
일반적으로 space 4를 하나의 탭으로 보는데, 스페이스를 정확히 맞추는건 어려운 것 입니다.<br>
당장 ReadME 파일은 space 2로 인식됨

```
if state1():
  print(10)

```
파이썬 블록을 포기한다해도, 역시 중괄호 {}는 귀찮습니다. 따라서 ruby, lua처럼 end를 쓰는게 좋다고 판단했습니다. <br>
단, 파이썬 루비 둘 다 블록을 시작할때 : 혹은 do를 쓰는데, 의미도 없으므로 Nok lang에선 생략합니다.

물론 파이썬 방식을 포기하면, 여전히 번거롭게
```
{{{{ }}}}
    end
  end
end
```

이런 노가다를 해야할 수 있습니다. 아직까지는 Tab을 이용하지 않으면 해결할 수 없는 문제입니다.<br>
그럼에도, 조금 줄일 수 있는 팁이 있다고 하면, `endfunc` 같은 키워드 만들거나VB Net처럼 `end func` `end:func` 이런식으로 하는 것 입니다.
그러면 짜잔
```
func main()
  while blabla
    if n==10
      io.print('어쩌고 저쩌고')
end:func

근데 생각해보니 }}} 이렇게 쓰면 되는거 아닌가?
```

완벽하진 않아도 쉽게 축약이 됩니다. 파이썬 정도는 아니라도 비슷한 효과를 낼 수는 있죠<br>
마음에 안 들면 님이 해보셈 <br>
다른 방식도 있는데 굳이 설명 안하겠습니다. 궁금하면 예전에 만든 [ipari 스크립트](https://github.com/Noksek2/ipari-script) 참고

- Python : 축약 O, 탭 독립성 X
- Ruby : 축약 X, 탭 독립성 O
- Nok : 축약 △, 탭 독립성 O

# 자료형 (Type)
파이썬처럼 mut(가변), immut(불변) 두 가지를 지원, 
기본 자료형은 반드시 immut에 속함
## 기본 자료형 (Basic Type)
### 불변(Immutable Type)
- byte 1byte
- short 2byte
- int 4byte
- long 8byte
- ubyte, ushort, uint, ulong 
- float 4byte
- double 8byte
- char 2byte
- str 
키워드는 기본적으로 C/C++, Java를 따름<br>
double을 real로 대체할까 생각했지만 새로운 키워드 만들어도 혼란만 생길듯해 포기

`char`는 Java처럼 2바이트 와이드캐릭터를 사용, 0~2^16-1 사용가능<br>
(굳이 1바이트를 쓸거면 byte 권장)
`str`는 Rust처럼 문자열 리터럴

### 가변 (Mutable Type)
- String
- Array
- Dict

필요에 따라 추가 예정<br>
클래스로 선언한 식별자는 전부 가변형(Mutable Type)임
### Array, Tuple
#### 2-1. 고정 배열과 튜플
Nok lang에서 독특한 점 중 하나는 배열을 다루는 방식입니다.
[]를 통해서 배열, 튜플을 동시에 정의할 수 있습니다.

LLVM, Rust의 배열 선언방식과 유사합니다. (영향을 받은건 아님. 굳이 따지면 수렴진화?)

```
#배열
:[int] #크기 1의 int 배열로 취급
:[int*1] #똑같음
:[int*2] #크기 2의 int 배열
#튜플
:[int, int] : 튜플
:[int, float] #튜플
:[int*2, float*2] # :[int int float float]와 같음

a:[int, int]=[100 200] #a:[int*2]=[100 200]
```
이런 식의 선언방식을 통해 배열, 튜플 동시에 나타낼 수 있습니다.<br>
`:[int, int]`는 `:[int int]` 식으로 콤마를 생략해 쓸 수도 있습니다. `int*3`에서 뒤에 정수 리터럴리 오는 경우 `*` 생략 가능<br>
`int*size`의 경우는 불가능

```
#가능한 문법
:[int, int, int]
:[int int int]
:[int*3]
:[int 3]
:[int*size] #size:int=100 일 때

#문법 오류
:[int size] #동적 할당의 경우 반드시 * 사용
```
`:[int int]`와 `:[int*2]`는 사용방식은 비슷하나, 왼쪽은 튜플로써, 오른쪽은 배열로 처리됩니다.<br>
처음에는 통합하려 했는데 일관성이나 뒤에 *객체*를 표현할때 튜플로 타입을 나타낼텐데, 배열과 튜플이 혼용되면 곤란하기 때문입니다. <br> 



#### 2-2. 다중 배열
`:[[int*5]*5]`
처럼 사용하면 됩니다. 이는 5*5 배열을 의미합니다.
좀 보기 싫겠지만 익숙해지면 그만임
```
arr:[[int*3]*3]=[[1,2,3],[4,5,6],[7,8,9]]
mixarr:[[int float]*2]=[[1 10.f][3 1.f]]
```

#### 2-3. 동적 배열
위 처럼 사용하면 정적 배열(고정 배열)이 되나, 동적 배열을 사용하려면 `[int **]` 처럼 쓸 수 있습니다.
```
size:int=100
darr:[int **]=[1,2,3,4] #
darr2:[int*size] #size 크기의 배열 할당 (size>0을 만족하지 않으면 런타임에서 오류)
```
선언이 귀찮을 때 `arr=[1,2,3,4 ;*]` 같이 넣을까 생각도 해봤는데 아직 미정.<br>
참고로 튜플은 고정 크기이므로 
```[int*2 float **]``` 는 불가능한 문법입니다.
사실 재미는 있지만 메모리 관리 면에서 번거로울 듯 하여서

### Dict
Dict<str,int>처럼 별도로 선언하는 방식도 있으나, 배열과 마찬가지로
`[str:int]`
를 사용할 수도 있습니다.
```
dict_i2i:[int:int]=[0:10, 1:50]
dict_s2i:[str:int]=['myson':100, 'yourson':200]

prices:[str:int]=['김밥':2000 '떡볶이':3500 '순대':3000]
prices['김밥'] #2000


```
Key는 immut 타입만 지원할 수 있습니다.


## 객체(Object) 기능?
"컴파일러 구현하기 어려우면 NG"라는 규칙에 따라서<br>
클래스 기반 언어가 되진 않을것 같습니다. 클래스의 기능은 막강한 반면 키워드 규칙 등이 많습니다.
절차지향은 아니지만 Go처럼 무늬는 흉내내는 느낌으로 구상 중

```
#[float float]? [float 2]
struct Pos
  x:float
  y:float
end
func main
  pos:Pos
  print(10,-20, -30, -40)

n=84
[int 3]
[float 4]

[int int]
[float float]
[[float float]2 int 2]
[float *]
[Pos ]
struct Chara
  use Pos
  
:[str:Chara]

```

# 구문 분석 시 발견되는 문제가 있는가

발견하면 바로 수정함


